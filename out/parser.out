Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> exp
Rule 1     exp -> term binop exp
Rule 2     exp -> term
Rule 3     exp -> IF exp THEN exp ELSE exp
Rule 4     exp -> LET def IN exp
Rule 5     exp -> MAP idlist TO exp
Rule 6     term -> unop term
Rule 7     term -> factor OPEN_PAREN explist CLOSE_PAREN
Rule 8     term -> factor
Rule 9     term -> bool
Rule 10    term -> int
Rule 11    term -> empty
Rule 12    factor -> OPEN_PAREN exp CLOSE_PAREN
Rule 13    factor -> prim
Rule 14    factor -> id
Rule 15    def -> id EQ exp SEMI_COLON def
Rule 16    def -> id EQ exp SEMI_COLON
Rule 17    explist -> propexplist
Rule 18    explist -> <empty>
Rule 19    propexplist -> exp COMMA propexplist
Rule 20    propexplist -> exp
Rule 21    idlist -> propidlist
Rule 22    idlist -> <empty>
Rule 23    propidlist -> id COMMA propidlist
Rule 24    propidlist -> id
Rule 25    bool -> FALSE
Rule 26    bool -> TRUE
Rule 27    sign -> PLUS
Rule 28    sign -> MINUS
Rule 29    unop -> sign
Rule 30    unop -> ~
Rule 31    binop -> sign
Rule 32    binop -> OPERATOR
Rule 33    prim -> NUMBER_Q
Rule 34    prim -> CONS_Q
Rule 35    prim -> EMPTY_Q
Rule 36    prim -> FUNCTION_Q
Rule 37    prim -> LIST_Q
Rule 38    prim -> ARITY
Rule 39    prim -> CONS
Rule 40    prim -> DELIMITER
Rule 41    prim -> FIRST
Rule 42    prim -> REST
Rule 43    id -> id DIGIT
Rule 44    id -> id CHARACTER
Rule 45    id -> CHARACTER
Rule 46    int -> int DIGIT
Rule 47    int -> DIGIT
Rule 48    empty -> EMPTY

Terminals, with rules where they appear

ARITY                : 38
CHARACTER            : 44 45
CLOSE_PAREN          : 7 12
COMMA                : 19 23
CONS                 : 39
CONS_Q               : 34
DELIMITER            : 40
DIGIT                : 43 46 47
ELSE                 : 3
EMPTY                : 48
EMPTY_Q              : 35
EQ                   : 15 16
FALSE                : 25
FIRST                : 41
FUNCTION_Q           : 36
IF                   : 3
IN                   : 4
LET                  : 4
LIST_Q               : 37
MAP                  : 5
MINUS                : 28
NUMBER_Q             : 33
OPEN_PAREN           : 7 12
OPERATOR             : 32
PLUS                 : 27
REST                 : 42
SEMI_COLON           : 15 16
THEN                 : 3
TO                   : 5
TRUE                 : 26
error                : 
~                    : 30

Nonterminals, with rules where they appear

binop                : 1
bool                 : 9
def                  : 4 15
empty                : 11
exp                  : 1 3 3 3 4 5 12 15 16 19 20 0
explist              : 7
factor               : 7 8
id                   : 14 15 16 23 24 43 44
idlist               : 5
int                  : 10 46
prim                 : 13
propexplist          : 17 19
propidlist           : 21 23
sign                 : 29 31
term                 : 1 2 6
unop                 : 6

Parsing method: LALR

state 0

    (0) S' -> . exp
    (1) exp -> . term binop exp
    (2) exp -> . term
    (3) exp -> . IF exp THEN exp ELSE exp
    (4) exp -> . LET def IN exp
    (5) exp -> . MAP idlist TO exp
    (6) term -> . unop term
    (7) term -> . factor OPEN_PAREN explist CLOSE_PAREN
    (8) term -> . factor
    (9) term -> . bool
    (10) term -> . int
    (11) term -> . empty
    (29) unop -> . sign
    (30) unop -> . ~
    (12) factor -> . OPEN_PAREN exp CLOSE_PAREN
    (13) factor -> . prim
    (14) factor -> . id
    (25) bool -> . FALSE
    (26) bool -> . TRUE
    (46) int -> . int DIGIT
    (47) int -> . DIGIT
    (48) empty -> . EMPTY
    (27) sign -> . PLUS
    (28) sign -> . MINUS
    (33) prim -> . NUMBER_Q
    (34) prim -> . CONS_Q
    (35) prim -> . EMPTY_Q
    (36) prim -> . FUNCTION_Q
    (37) prim -> . LIST_Q
    (38) prim -> . ARITY
    (39) prim -> . CONS
    (40) prim -> . DELIMITER
    (41) prim -> . FIRST
    (42) prim -> . REST
    (43) id -> . id DIGIT
    (44) id -> . id CHARACTER
    (45) id -> . CHARACTER

    IF              shift and go to state 3
    LET             shift and go to state 4
    MAP             shift and go to state 5
    ~               shift and go to state 13
    OPEN_PAREN      shift and go to state 8
    FALSE           shift and go to state 16
    TRUE            shift and go to state 17
    DIGIT           shift and go to state 18
    EMPTY           shift and go to state 19
    PLUS            shift and go to state 20
    MINUS           shift and go to state 21
    NUMBER_Q        shift and go to state 22
    CONS_Q          shift and go to state 23
    EMPTY_Q         shift and go to state 24
    FUNCTION_Q      shift and go to state 25
    LIST_Q          shift and go to state 26
    ARITY           shift and go to state 27
    CONS            shift and go to state 28
    DELIMITER       shift and go to state 29
    FIRST           shift and go to state 30
    REST            shift and go to state 31
    CHARACTER       shift and go to state 32

    exp                            shift and go to state 1
    term                           shift and go to state 2
    unop                           shift and go to state 6
    factor                         shift and go to state 7
    bool                           shift and go to state 9
    int                            shift and go to state 10
    empty                          shift and go to state 11
    sign                           shift and go to state 12
    prim                           shift and go to state 14
    id                             shift and go to state 15

state 1

    (0) S' -> exp .



state 2

    (1) exp -> term . binop exp
    (2) exp -> term .
    (31) binop -> . sign
    (32) binop -> . OPERATOR
    (27) sign -> . PLUS
    (28) sign -> . MINUS

    $end            reduce using rule 2 (exp -> term .)
    THEN            reduce using rule 2 (exp -> term .)
    CLOSE_PAREN     reduce using rule 2 (exp -> term .)
    COMMA           reduce using rule 2 (exp -> term .)
    ELSE            reduce using rule 2 (exp -> term .)
    SEMI_COLON      reduce using rule 2 (exp -> term .)
    OPERATOR        shift and go to state 35
    PLUS            shift and go to state 20
    MINUS           shift and go to state 21

    binop                          shift and go to state 33
    sign                           shift and go to state 34

state 3

    (3) exp -> IF . exp THEN exp ELSE exp
    (1) exp -> . term binop exp
    (2) exp -> . term
    (3) exp -> . IF exp THEN exp ELSE exp
    (4) exp -> . LET def IN exp
    (5) exp -> . MAP idlist TO exp
    (6) term -> . unop term
    (7) term -> . factor OPEN_PAREN explist CLOSE_PAREN
    (8) term -> . factor
    (9) term -> . bool
    (10) term -> . int
    (11) term -> . empty
    (29) unop -> . sign
    (30) unop -> . ~
    (12) factor -> . OPEN_PAREN exp CLOSE_PAREN
    (13) factor -> . prim
    (14) factor -> . id
    (25) bool -> . FALSE
    (26) bool -> . TRUE
    (46) int -> . int DIGIT
    (47) int -> . DIGIT
    (48) empty -> . EMPTY
    (27) sign -> . PLUS
    (28) sign -> . MINUS
    (33) prim -> . NUMBER_Q
    (34) prim -> . CONS_Q
    (35) prim -> . EMPTY_Q
    (36) prim -> . FUNCTION_Q
    (37) prim -> . LIST_Q
    (38) prim -> . ARITY
    (39) prim -> . CONS
    (40) prim -> . DELIMITER
    (41) prim -> . FIRST
    (42) prim -> . REST
    (43) id -> . id DIGIT
    (44) id -> . id CHARACTER
    (45) id -> . CHARACTER

    IF              shift and go to state 3
    LET             shift and go to state 4
    MAP             shift and go to state 5
    ~               shift and go to state 13
    OPEN_PAREN      shift and go to state 8
    FALSE           shift and go to state 16
    TRUE            shift and go to state 17
    DIGIT           shift and go to state 18
    EMPTY           shift and go to state 19
    PLUS            shift and go to state 20
    MINUS           shift and go to state 21
    NUMBER_Q        shift and go to state 22
    CONS_Q          shift and go to state 23
    EMPTY_Q         shift and go to state 24
    FUNCTION_Q      shift and go to state 25
    LIST_Q          shift and go to state 26
    ARITY           shift and go to state 27
    CONS            shift and go to state 28
    DELIMITER       shift and go to state 29
    FIRST           shift and go to state 30
    REST            shift and go to state 31
    CHARACTER       shift and go to state 32

    exp                            shift and go to state 36
    term                           shift and go to state 2
    unop                           shift and go to state 6
    factor                         shift and go to state 7
    bool                           shift and go to state 9
    int                            shift and go to state 10
    empty                          shift and go to state 11
    sign                           shift and go to state 12
    prim                           shift and go to state 14
    id                             shift and go to state 15

state 4

    (4) exp -> LET . def IN exp
    (15) def -> . id EQ exp SEMI_COLON def
    (16) def -> . id EQ exp SEMI_COLON
    (43) id -> . id DIGIT
    (44) id -> . id CHARACTER
    (45) id -> . CHARACTER

    CHARACTER       shift and go to state 32

    def                            shift and go to state 37
    id                             shift and go to state 38

state 5

    (5) exp -> MAP . idlist TO exp
    (21) idlist -> . propidlist
    (22) idlist -> .
    (23) propidlist -> . id COMMA propidlist
    (24) propidlist -> . id
    (43) id -> . id DIGIT
    (44) id -> . id CHARACTER
    (45) id -> . CHARACTER

    TO              reduce using rule 22 (idlist -> .)
    CHARACTER       shift and go to state 32

    idlist                         shift and go to state 39
    propidlist                     shift and go to state 40
    id                             shift and go to state 41

state 6

    (6) term -> unop . term
    (6) term -> . unop term
    (7) term -> . factor OPEN_PAREN explist CLOSE_PAREN
    (8) term -> . factor
    (9) term -> . bool
    (10) term -> . int
    (11) term -> . empty
    (29) unop -> . sign
    (30) unop -> . ~
    (12) factor -> . OPEN_PAREN exp CLOSE_PAREN
    (13) factor -> . prim
    (14) factor -> . id
    (25) bool -> . FALSE
    (26) bool -> . TRUE
    (46) int -> . int DIGIT
    (47) int -> . DIGIT
    (48) empty -> . EMPTY
    (27) sign -> . PLUS
    (28) sign -> . MINUS
    (33) prim -> . NUMBER_Q
    (34) prim -> . CONS_Q
    (35) prim -> . EMPTY_Q
    (36) prim -> . FUNCTION_Q
    (37) prim -> . LIST_Q
    (38) prim -> . ARITY
    (39) prim -> . CONS
    (40) prim -> . DELIMITER
    (41) prim -> . FIRST
    (42) prim -> . REST
    (43) id -> . id DIGIT
    (44) id -> . id CHARACTER
    (45) id -> . CHARACTER

    ~               shift and go to state 13
    OPEN_PAREN      shift and go to state 8
    FALSE           shift and go to state 16
    TRUE            shift and go to state 17
    DIGIT           shift and go to state 18
    EMPTY           shift and go to state 19
    PLUS            shift and go to state 20
    MINUS           shift and go to state 21
    NUMBER_Q        shift and go to state 22
    CONS_Q          shift and go to state 23
    EMPTY_Q         shift and go to state 24
    FUNCTION_Q      shift and go to state 25
    LIST_Q          shift and go to state 26
    ARITY           shift and go to state 27
    CONS            shift and go to state 28
    DELIMITER       shift and go to state 29
    FIRST           shift and go to state 30
    REST            shift and go to state 31
    CHARACTER       shift and go to state 32

    unop                           shift and go to state 6
    term                           shift and go to state 42
    factor                         shift and go to state 7
    bool                           shift and go to state 9
    int                            shift and go to state 10
    empty                          shift and go to state 11
    sign                           shift and go to state 12
    prim                           shift and go to state 14
    id                             shift and go to state 15

state 7

    (7) term -> factor . OPEN_PAREN explist CLOSE_PAREN
    (8) term -> factor .

    OPEN_PAREN      shift and go to state 43
    OPERATOR        reduce using rule 8 (term -> factor .)
    PLUS            reduce using rule 8 (term -> factor .)
    MINUS           reduce using rule 8 (term -> factor .)
    $end            reduce using rule 8 (term -> factor .)
    THEN            reduce using rule 8 (term -> factor .)
    CLOSE_PAREN     reduce using rule 8 (term -> factor .)
    COMMA           reduce using rule 8 (term -> factor .)
    ELSE            reduce using rule 8 (term -> factor .)
    SEMI_COLON      reduce using rule 8 (term -> factor .)


state 8

    (12) factor -> OPEN_PAREN . exp CLOSE_PAREN
    (1) exp -> . term binop exp
    (2) exp -> . term
    (3) exp -> . IF exp THEN exp ELSE exp
    (4) exp -> . LET def IN exp
    (5) exp -> . MAP idlist TO exp
    (6) term -> . unop term
    (7) term -> . factor OPEN_PAREN explist CLOSE_PAREN
    (8) term -> . factor
    (9) term -> . bool
    (10) term -> . int
    (11) term -> . empty
    (29) unop -> . sign
    (30) unop -> . ~
    (12) factor -> . OPEN_PAREN exp CLOSE_PAREN
    (13) factor -> . prim
    (14) factor -> . id
    (25) bool -> . FALSE
    (26) bool -> . TRUE
    (46) int -> . int DIGIT
    (47) int -> . DIGIT
    (48) empty -> . EMPTY
    (27) sign -> . PLUS
    (28) sign -> . MINUS
    (33) prim -> . NUMBER_Q
    (34) prim -> . CONS_Q
    (35) prim -> . EMPTY_Q
    (36) prim -> . FUNCTION_Q
    (37) prim -> . LIST_Q
    (38) prim -> . ARITY
    (39) prim -> . CONS
    (40) prim -> . DELIMITER
    (41) prim -> . FIRST
    (42) prim -> . REST
    (43) id -> . id DIGIT
    (44) id -> . id CHARACTER
    (45) id -> . CHARACTER

    IF              shift and go to state 3
    LET             shift and go to state 4
    MAP             shift and go to state 5
    ~               shift and go to state 13
    OPEN_PAREN      shift and go to state 8
    FALSE           shift and go to state 16
    TRUE            shift and go to state 17
    DIGIT           shift and go to state 18
    EMPTY           shift and go to state 19
    PLUS            shift and go to state 20
    MINUS           shift and go to state 21
    NUMBER_Q        shift and go to state 22
    CONS_Q          shift and go to state 23
    EMPTY_Q         shift and go to state 24
    FUNCTION_Q      shift and go to state 25
    LIST_Q          shift and go to state 26
    ARITY           shift and go to state 27
    CONS            shift and go to state 28
    DELIMITER       shift and go to state 29
    FIRST           shift and go to state 30
    REST            shift and go to state 31
    CHARACTER       shift and go to state 32

    exp                            shift and go to state 44
    term                           shift and go to state 2
    unop                           shift and go to state 6
    factor                         shift and go to state 7
    bool                           shift and go to state 9
    int                            shift and go to state 10
    empty                          shift and go to state 11
    sign                           shift and go to state 12
    prim                           shift and go to state 14
    id                             shift and go to state 15

state 9

    (9) term -> bool .

    OPERATOR        reduce using rule 9 (term -> bool .)
    PLUS            reduce using rule 9 (term -> bool .)
    MINUS           reduce using rule 9 (term -> bool .)
    $end            reduce using rule 9 (term -> bool .)
    THEN            reduce using rule 9 (term -> bool .)
    CLOSE_PAREN     reduce using rule 9 (term -> bool .)
    COMMA           reduce using rule 9 (term -> bool .)
    ELSE            reduce using rule 9 (term -> bool .)
    SEMI_COLON      reduce using rule 9 (term -> bool .)


state 10

    (10) term -> int .
    (46) int -> int . DIGIT

    OPERATOR        reduce using rule 10 (term -> int .)
    PLUS            reduce using rule 10 (term -> int .)
    MINUS           reduce using rule 10 (term -> int .)
    $end            reduce using rule 10 (term -> int .)
    THEN            reduce using rule 10 (term -> int .)
    CLOSE_PAREN     reduce using rule 10 (term -> int .)
    COMMA           reduce using rule 10 (term -> int .)
    ELSE            reduce using rule 10 (term -> int .)
    SEMI_COLON      reduce using rule 10 (term -> int .)
    DIGIT           shift and go to state 45


state 11

    (11) term -> empty .

    OPERATOR        reduce using rule 11 (term -> empty .)
    PLUS            reduce using rule 11 (term -> empty .)
    MINUS           reduce using rule 11 (term -> empty .)
    $end            reduce using rule 11 (term -> empty .)
    THEN            reduce using rule 11 (term -> empty .)
    CLOSE_PAREN     reduce using rule 11 (term -> empty .)
    COMMA           reduce using rule 11 (term -> empty .)
    ELSE            reduce using rule 11 (term -> empty .)
    SEMI_COLON      reduce using rule 11 (term -> empty .)


state 12

    (29) unop -> sign .

    ~               reduce using rule 29 (unop -> sign .)
    OPEN_PAREN      reduce using rule 29 (unop -> sign .)
    FALSE           reduce using rule 29 (unop -> sign .)
    TRUE            reduce using rule 29 (unop -> sign .)
    DIGIT           reduce using rule 29 (unop -> sign .)
    EMPTY           reduce using rule 29 (unop -> sign .)
    PLUS            reduce using rule 29 (unop -> sign .)
    MINUS           reduce using rule 29 (unop -> sign .)
    NUMBER_Q        reduce using rule 29 (unop -> sign .)
    CONS_Q          reduce using rule 29 (unop -> sign .)
    EMPTY_Q         reduce using rule 29 (unop -> sign .)
    FUNCTION_Q      reduce using rule 29 (unop -> sign .)
    LIST_Q          reduce using rule 29 (unop -> sign .)
    ARITY           reduce using rule 29 (unop -> sign .)
    CONS            reduce using rule 29 (unop -> sign .)
    DELIMITER       reduce using rule 29 (unop -> sign .)
    FIRST           reduce using rule 29 (unop -> sign .)
    REST            reduce using rule 29 (unop -> sign .)
    CHARACTER       reduce using rule 29 (unop -> sign .)


state 13

    (30) unop -> ~ .

    ~               reduce using rule 30 (unop -> ~ .)
    OPEN_PAREN      reduce using rule 30 (unop -> ~ .)
    FALSE           reduce using rule 30 (unop -> ~ .)
    TRUE            reduce using rule 30 (unop -> ~ .)
    DIGIT           reduce using rule 30 (unop -> ~ .)
    EMPTY           reduce using rule 30 (unop -> ~ .)
    PLUS            reduce using rule 30 (unop -> ~ .)
    MINUS           reduce using rule 30 (unop -> ~ .)
    NUMBER_Q        reduce using rule 30 (unop -> ~ .)
    CONS_Q          reduce using rule 30 (unop -> ~ .)
    EMPTY_Q         reduce using rule 30 (unop -> ~ .)
    FUNCTION_Q      reduce using rule 30 (unop -> ~ .)
    LIST_Q          reduce using rule 30 (unop -> ~ .)
    ARITY           reduce using rule 30 (unop -> ~ .)
    CONS            reduce using rule 30 (unop -> ~ .)
    DELIMITER       reduce using rule 30 (unop -> ~ .)
    FIRST           reduce using rule 30 (unop -> ~ .)
    REST            reduce using rule 30 (unop -> ~ .)
    CHARACTER       reduce using rule 30 (unop -> ~ .)


state 14

    (13) factor -> prim .

    OPEN_PAREN      reduce using rule 13 (factor -> prim .)
    OPERATOR        reduce using rule 13 (factor -> prim .)
    PLUS            reduce using rule 13 (factor -> prim .)
    MINUS           reduce using rule 13 (factor -> prim .)
    $end            reduce using rule 13 (factor -> prim .)
    THEN            reduce using rule 13 (factor -> prim .)
    CLOSE_PAREN     reduce using rule 13 (factor -> prim .)
    COMMA           reduce using rule 13 (factor -> prim .)
    ELSE            reduce using rule 13 (factor -> prim .)
    SEMI_COLON      reduce using rule 13 (factor -> prim .)


state 15

    (14) factor -> id .
    (43) id -> id . DIGIT
    (44) id -> id . CHARACTER

    OPEN_PAREN      reduce using rule 14 (factor -> id .)
    OPERATOR        reduce using rule 14 (factor -> id .)
    PLUS            reduce using rule 14 (factor -> id .)
    MINUS           reduce using rule 14 (factor -> id .)
    $end            reduce using rule 14 (factor -> id .)
    THEN            reduce using rule 14 (factor -> id .)
    CLOSE_PAREN     reduce using rule 14 (factor -> id .)
    COMMA           reduce using rule 14 (factor -> id .)
    ELSE            reduce using rule 14 (factor -> id .)
    SEMI_COLON      reduce using rule 14 (factor -> id .)
    DIGIT           shift and go to state 46
    CHARACTER       shift and go to state 47


state 16

    (25) bool -> FALSE .

    OPERATOR        reduce using rule 25 (bool -> FALSE .)
    PLUS            reduce using rule 25 (bool -> FALSE .)
    MINUS           reduce using rule 25 (bool -> FALSE .)
    $end            reduce using rule 25 (bool -> FALSE .)
    THEN            reduce using rule 25 (bool -> FALSE .)
    CLOSE_PAREN     reduce using rule 25 (bool -> FALSE .)
    COMMA           reduce using rule 25 (bool -> FALSE .)
    ELSE            reduce using rule 25 (bool -> FALSE .)
    SEMI_COLON      reduce using rule 25 (bool -> FALSE .)


state 17

    (26) bool -> TRUE .

    OPERATOR        reduce using rule 26 (bool -> TRUE .)
    PLUS            reduce using rule 26 (bool -> TRUE .)
    MINUS           reduce using rule 26 (bool -> TRUE .)
    $end            reduce using rule 26 (bool -> TRUE .)
    THEN            reduce using rule 26 (bool -> TRUE .)
    CLOSE_PAREN     reduce using rule 26 (bool -> TRUE .)
    COMMA           reduce using rule 26 (bool -> TRUE .)
    ELSE            reduce using rule 26 (bool -> TRUE .)
    SEMI_COLON      reduce using rule 26 (bool -> TRUE .)


state 18

    (47) int -> DIGIT .

    DIGIT           reduce using rule 47 (int -> DIGIT .)
    OPERATOR        reduce using rule 47 (int -> DIGIT .)
    PLUS            reduce using rule 47 (int -> DIGIT .)
    MINUS           reduce using rule 47 (int -> DIGIT .)
    $end            reduce using rule 47 (int -> DIGIT .)
    THEN            reduce using rule 47 (int -> DIGIT .)
    CLOSE_PAREN     reduce using rule 47 (int -> DIGIT .)
    COMMA           reduce using rule 47 (int -> DIGIT .)
    ELSE            reduce using rule 47 (int -> DIGIT .)
    SEMI_COLON      reduce using rule 47 (int -> DIGIT .)


state 19

    (48) empty -> EMPTY .

    OPERATOR        reduce using rule 48 (empty -> EMPTY .)
    PLUS            reduce using rule 48 (empty -> EMPTY .)
    MINUS           reduce using rule 48 (empty -> EMPTY .)
    $end            reduce using rule 48 (empty -> EMPTY .)
    THEN            reduce using rule 48 (empty -> EMPTY .)
    CLOSE_PAREN     reduce using rule 48 (empty -> EMPTY .)
    COMMA           reduce using rule 48 (empty -> EMPTY .)
    ELSE            reduce using rule 48 (empty -> EMPTY .)
    SEMI_COLON      reduce using rule 48 (empty -> EMPTY .)


state 20

    (27) sign -> PLUS .

    ~               reduce using rule 27 (sign -> PLUS .)
    OPEN_PAREN      reduce using rule 27 (sign -> PLUS .)
    FALSE           reduce using rule 27 (sign -> PLUS .)
    TRUE            reduce using rule 27 (sign -> PLUS .)
    DIGIT           reduce using rule 27 (sign -> PLUS .)
    EMPTY           reduce using rule 27 (sign -> PLUS .)
    PLUS            reduce using rule 27 (sign -> PLUS .)
    MINUS           reduce using rule 27 (sign -> PLUS .)
    NUMBER_Q        reduce using rule 27 (sign -> PLUS .)
    CONS_Q          reduce using rule 27 (sign -> PLUS .)
    EMPTY_Q         reduce using rule 27 (sign -> PLUS .)
    FUNCTION_Q      reduce using rule 27 (sign -> PLUS .)
    LIST_Q          reduce using rule 27 (sign -> PLUS .)
    ARITY           reduce using rule 27 (sign -> PLUS .)
    CONS            reduce using rule 27 (sign -> PLUS .)
    DELIMITER       reduce using rule 27 (sign -> PLUS .)
    FIRST           reduce using rule 27 (sign -> PLUS .)
    REST            reduce using rule 27 (sign -> PLUS .)
    CHARACTER       reduce using rule 27 (sign -> PLUS .)
    IF              reduce using rule 27 (sign -> PLUS .)
    LET             reduce using rule 27 (sign -> PLUS .)
    MAP             reduce using rule 27 (sign -> PLUS .)


state 21

    (28) sign -> MINUS .

    ~               reduce using rule 28 (sign -> MINUS .)
    OPEN_PAREN      reduce using rule 28 (sign -> MINUS .)
    FALSE           reduce using rule 28 (sign -> MINUS .)
    TRUE            reduce using rule 28 (sign -> MINUS .)
    DIGIT           reduce using rule 28 (sign -> MINUS .)
    EMPTY           reduce using rule 28 (sign -> MINUS .)
    PLUS            reduce using rule 28 (sign -> MINUS .)
    MINUS           reduce using rule 28 (sign -> MINUS .)
    NUMBER_Q        reduce using rule 28 (sign -> MINUS .)
    CONS_Q          reduce using rule 28 (sign -> MINUS .)
    EMPTY_Q         reduce using rule 28 (sign -> MINUS .)
    FUNCTION_Q      reduce using rule 28 (sign -> MINUS .)
    LIST_Q          reduce using rule 28 (sign -> MINUS .)
    ARITY           reduce using rule 28 (sign -> MINUS .)
    CONS            reduce using rule 28 (sign -> MINUS .)
    DELIMITER       reduce using rule 28 (sign -> MINUS .)
    FIRST           reduce using rule 28 (sign -> MINUS .)
    REST            reduce using rule 28 (sign -> MINUS .)
    CHARACTER       reduce using rule 28 (sign -> MINUS .)
    IF              reduce using rule 28 (sign -> MINUS .)
    LET             reduce using rule 28 (sign -> MINUS .)
    MAP             reduce using rule 28 (sign -> MINUS .)


state 22

    (33) prim -> NUMBER_Q .

    OPEN_PAREN      reduce using rule 33 (prim -> NUMBER_Q .)
    OPERATOR        reduce using rule 33 (prim -> NUMBER_Q .)
    PLUS            reduce using rule 33 (prim -> NUMBER_Q .)
    MINUS           reduce using rule 33 (prim -> NUMBER_Q .)
    $end            reduce using rule 33 (prim -> NUMBER_Q .)
    THEN            reduce using rule 33 (prim -> NUMBER_Q .)
    CLOSE_PAREN     reduce using rule 33 (prim -> NUMBER_Q .)
    COMMA           reduce using rule 33 (prim -> NUMBER_Q .)
    ELSE            reduce using rule 33 (prim -> NUMBER_Q .)
    SEMI_COLON      reduce using rule 33 (prim -> NUMBER_Q .)


state 23

    (34) prim -> CONS_Q .

    OPEN_PAREN      reduce using rule 34 (prim -> CONS_Q .)
    OPERATOR        reduce using rule 34 (prim -> CONS_Q .)
    PLUS            reduce using rule 34 (prim -> CONS_Q .)
    MINUS           reduce using rule 34 (prim -> CONS_Q .)
    $end            reduce using rule 34 (prim -> CONS_Q .)
    THEN            reduce using rule 34 (prim -> CONS_Q .)
    CLOSE_PAREN     reduce using rule 34 (prim -> CONS_Q .)
    COMMA           reduce using rule 34 (prim -> CONS_Q .)
    ELSE            reduce using rule 34 (prim -> CONS_Q .)
    SEMI_COLON      reduce using rule 34 (prim -> CONS_Q .)


state 24

    (35) prim -> EMPTY_Q .

    OPEN_PAREN      reduce using rule 35 (prim -> EMPTY_Q .)
    OPERATOR        reduce using rule 35 (prim -> EMPTY_Q .)
    PLUS            reduce using rule 35 (prim -> EMPTY_Q .)
    MINUS           reduce using rule 35 (prim -> EMPTY_Q .)
    $end            reduce using rule 35 (prim -> EMPTY_Q .)
    THEN            reduce using rule 35 (prim -> EMPTY_Q .)
    CLOSE_PAREN     reduce using rule 35 (prim -> EMPTY_Q .)
    COMMA           reduce using rule 35 (prim -> EMPTY_Q .)
    ELSE            reduce using rule 35 (prim -> EMPTY_Q .)
    SEMI_COLON      reduce using rule 35 (prim -> EMPTY_Q .)


state 25

    (36) prim -> FUNCTION_Q .

    OPEN_PAREN      reduce using rule 36 (prim -> FUNCTION_Q .)
    OPERATOR        reduce using rule 36 (prim -> FUNCTION_Q .)
    PLUS            reduce using rule 36 (prim -> FUNCTION_Q .)
    MINUS           reduce using rule 36 (prim -> FUNCTION_Q .)
    $end            reduce using rule 36 (prim -> FUNCTION_Q .)
    THEN            reduce using rule 36 (prim -> FUNCTION_Q .)
    CLOSE_PAREN     reduce using rule 36 (prim -> FUNCTION_Q .)
    COMMA           reduce using rule 36 (prim -> FUNCTION_Q .)
    ELSE            reduce using rule 36 (prim -> FUNCTION_Q .)
    SEMI_COLON      reduce using rule 36 (prim -> FUNCTION_Q .)


state 26

    (37) prim -> LIST_Q .

    OPEN_PAREN      reduce using rule 37 (prim -> LIST_Q .)
    OPERATOR        reduce using rule 37 (prim -> LIST_Q .)
    PLUS            reduce using rule 37 (prim -> LIST_Q .)
    MINUS           reduce using rule 37 (prim -> LIST_Q .)
    $end            reduce using rule 37 (prim -> LIST_Q .)
    THEN            reduce using rule 37 (prim -> LIST_Q .)
    CLOSE_PAREN     reduce using rule 37 (prim -> LIST_Q .)
    COMMA           reduce using rule 37 (prim -> LIST_Q .)
    ELSE            reduce using rule 37 (prim -> LIST_Q .)
    SEMI_COLON      reduce using rule 37 (prim -> LIST_Q .)


state 27

    (38) prim -> ARITY .

    OPEN_PAREN      reduce using rule 38 (prim -> ARITY .)
    OPERATOR        reduce using rule 38 (prim -> ARITY .)
    PLUS            reduce using rule 38 (prim -> ARITY .)
    MINUS           reduce using rule 38 (prim -> ARITY .)
    $end            reduce using rule 38 (prim -> ARITY .)
    THEN            reduce using rule 38 (prim -> ARITY .)
    CLOSE_PAREN     reduce using rule 38 (prim -> ARITY .)
    COMMA           reduce using rule 38 (prim -> ARITY .)
    ELSE            reduce using rule 38 (prim -> ARITY .)
    SEMI_COLON      reduce using rule 38 (prim -> ARITY .)


state 28

    (39) prim -> CONS .

    OPEN_PAREN      reduce using rule 39 (prim -> CONS .)
    OPERATOR        reduce using rule 39 (prim -> CONS .)
    PLUS            reduce using rule 39 (prim -> CONS .)
    MINUS           reduce using rule 39 (prim -> CONS .)
    $end            reduce using rule 39 (prim -> CONS .)
    THEN            reduce using rule 39 (prim -> CONS .)
    CLOSE_PAREN     reduce using rule 39 (prim -> CONS .)
    COMMA           reduce using rule 39 (prim -> CONS .)
    ELSE            reduce using rule 39 (prim -> CONS .)
    SEMI_COLON      reduce using rule 39 (prim -> CONS .)


state 29

    (40) prim -> DELIMITER .

    OPEN_PAREN      reduce using rule 40 (prim -> DELIMITER .)
    OPERATOR        reduce using rule 40 (prim -> DELIMITER .)
    PLUS            reduce using rule 40 (prim -> DELIMITER .)
    MINUS           reduce using rule 40 (prim -> DELIMITER .)
    $end            reduce using rule 40 (prim -> DELIMITER .)
    THEN            reduce using rule 40 (prim -> DELIMITER .)
    CLOSE_PAREN     reduce using rule 40 (prim -> DELIMITER .)
    COMMA           reduce using rule 40 (prim -> DELIMITER .)
    ELSE            reduce using rule 40 (prim -> DELIMITER .)
    SEMI_COLON      reduce using rule 40 (prim -> DELIMITER .)


state 30

    (41) prim -> FIRST .

    OPEN_PAREN      reduce using rule 41 (prim -> FIRST .)
    OPERATOR        reduce using rule 41 (prim -> FIRST .)
    PLUS            reduce using rule 41 (prim -> FIRST .)
    MINUS           reduce using rule 41 (prim -> FIRST .)
    $end            reduce using rule 41 (prim -> FIRST .)
    THEN            reduce using rule 41 (prim -> FIRST .)
    CLOSE_PAREN     reduce using rule 41 (prim -> FIRST .)
    COMMA           reduce using rule 41 (prim -> FIRST .)
    ELSE            reduce using rule 41 (prim -> FIRST .)
    SEMI_COLON      reduce using rule 41 (prim -> FIRST .)


state 31

    (42) prim -> REST .

    OPEN_PAREN      reduce using rule 42 (prim -> REST .)
    OPERATOR        reduce using rule 42 (prim -> REST .)
    PLUS            reduce using rule 42 (prim -> REST .)
    MINUS           reduce using rule 42 (prim -> REST .)
    $end            reduce using rule 42 (prim -> REST .)
    THEN            reduce using rule 42 (prim -> REST .)
    CLOSE_PAREN     reduce using rule 42 (prim -> REST .)
    COMMA           reduce using rule 42 (prim -> REST .)
    ELSE            reduce using rule 42 (prim -> REST .)
    SEMI_COLON      reduce using rule 42 (prim -> REST .)


state 32

    (45) id -> CHARACTER .

    DIGIT           reduce using rule 45 (id -> CHARACTER .)
    CHARACTER       reduce using rule 45 (id -> CHARACTER .)
    OPEN_PAREN      reduce using rule 45 (id -> CHARACTER .)
    OPERATOR        reduce using rule 45 (id -> CHARACTER .)
    PLUS            reduce using rule 45 (id -> CHARACTER .)
    MINUS           reduce using rule 45 (id -> CHARACTER .)
    $end            reduce using rule 45 (id -> CHARACTER .)
    THEN            reduce using rule 45 (id -> CHARACTER .)
    EQ              reduce using rule 45 (id -> CHARACTER .)
    COMMA           reduce using rule 45 (id -> CHARACTER .)
    TO              reduce using rule 45 (id -> CHARACTER .)
    CLOSE_PAREN     reduce using rule 45 (id -> CHARACTER .)
    ELSE            reduce using rule 45 (id -> CHARACTER .)
    SEMI_COLON      reduce using rule 45 (id -> CHARACTER .)


state 33

    (1) exp -> term binop . exp
    (1) exp -> . term binop exp
    (2) exp -> . term
    (3) exp -> . IF exp THEN exp ELSE exp
    (4) exp -> . LET def IN exp
    (5) exp -> . MAP idlist TO exp
    (6) term -> . unop term
    (7) term -> . factor OPEN_PAREN explist CLOSE_PAREN
    (8) term -> . factor
    (9) term -> . bool
    (10) term -> . int
    (11) term -> . empty
    (29) unop -> . sign
    (30) unop -> . ~
    (12) factor -> . OPEN_PAREN exp CLOSE_PAREN
    (13) factor -> . prim
    (14) factor -> . id
    (25) bool -> . FALSE
    (26) bool -> . TRUE
    (46) int -> . int DIGIT
    (47) int -> . DIGIT
    (48) empty -> . EMPTY
    (27) sign -> . PLUS
    (28) sign -> . MINUS
    (33) prim -> . NUMBER_Q
    (34) prim -> . CONS_Q
    (35) prim -> . EMPTY_Q
    (36) prim -> . FUNCTION_Q
    (37) prim -> . LIST_Q
    (38) prim -> . ARITY
    (39) prim -> . CONS
    (40) prim -> . DELIMITER
    (41) prim -> . FIRST
    (42) prim -> . REST
    (43) id -> . id DIGIT
    (44) id -> . id CHARACTER
    (45) id -> . CHARACTER

    IF              shift and go to state 3
    LET             shift and go to state 4
    MAP             shift and go to state 5
    ~               shift and go to state 13
    OPEN_PAREN      shift and go to state 8
    FALSE           shift and go to state 16
    TRUE            shift and go to state 17
    DIGIT           shift and go to state 18
    EMPTY           shift and go to state 19
    PLUS            shift and go to state 20
    MINUS           shift and go to state 21
    NUMBER_Q        shift and go to state 22
    CONS_Q          shift and go to state 23
    EMPTY_Q         shift and go to state 24
    FUNCTION_Q      shift and go to state 25
    LIST_Q          shift and go to state 26
    ARITY           shift and go to state 27
    CONS            shift and go to state 28
    DELIMITER       shift and go to state 29
    FIRST           shift and go to state 30
    REST            shift and go to state 31
    CHARACTER       shift and go to state 32

    term                           shift and go to state 2
    exp                            shift and go to state 48
    unop                           shift and go to state 6
    factor                         shift and go to state 7
    bool                           shift and go to state 9
    int                            shift and go to state 10
    empty                          shift and go to state 11
    sign                           shift and go to state 12
    prim                           shift and go to state 14
    id                             shift and go to state 15

state 34

    (31) binop -> sign .

    IF              reduce using rule 31 (binop -> sign .)
    LET             reduce using rule 31 (binop -> sign .)
    MAP             reduce using rule 31 (binop -> sign .)
    ~               reduce using rule 31 (binop -> sign .)
    OPEN_PAREN      reduce using rule 31 (binop -> sign .)
    FALSE           reduce using rule 31 (binop -> sign .)
    TRUE            reduce using rule 31 (binop -> sign .)
    DIGIT           reduce using rule 31 (binop -> sign .)
    EMPTY           reduce using rule 31 (binop -> sign .)
    PLUS            reduce using rule 31 (binop -> sign .)
    MINUS           reduce using rule 31 (binop -> sign .)
    NUMBER_Q        reduce using rule 31 (binop -> sign .)
    CONS_Q          reduce using rule 31 (binop -> sign .)
    EMPTY_Q         reduce using rule 31 (binop -> sign .)
    FUNCTION_Q      reduce using rule 31 (binop -> sign .)
    LIST_Q          reduce using rule 31 (binop -> sign .)
    ARITY           reduce using rule 31 (binop -> sign .)
    CONS            reduce using rule 31 (binop -> sign .)
    DELIMITER       reduce using rule 31 (binop -> sign .)
    FIRST           reduce using rule 31 (binop -> sign .)
    REST            reduce using rule 31 (binop -> sign .)
    CHARACTER       reduce using rule 31 (binop -> sign .)


state 35

    (32) binop -> OPERATOR .

    IF              reduce using rule 32 (binop -> OPERATOR .)
    LET             reduce using rule 32 (binop -> OPERATOR .)
    MAP             reduce using rule 32 (binop -> OPERATOR .)
    ~               reduce using rule 32 (binop -> OPERATOR .)
    OPEN_PAREN      reduce using rule 32 (binop -> OPERATOR .)
    FALSE           reduce using rule 32 (binop -> OPERATOR .)
    TRUE            reduce using rule 32 (binop -> OPERATOR .)
    DIGIT           reduce using rule 32 (binop -> OPERATOR .)
    EMPTY           reduce using rule 32 (binop -> OPERATOR .)
    PLUS            reduce using rule 32 (binop -> OPERATOR .)
    MINUS           reduce using rule 32 (binop -> OPERATOR .)
    NUMBER_Q        reduce using rule 32 (binop -> OPERATOR .)
    CONS_Q          reduce using rule 32 (binop -> OPERATOR .)
    EMPTY_Q         reduce using rule 32 (binop -> OPERATOR .)
    FUNCTION_Q      reduce using rule 32 (binop -> OPERATOR .)
    LIST_Q          reduce using rule 32 (binop -> OPERATOR .)
    ARITY           reduce using rule 32 (binop -> OPERATOR .)
    CONS            reduce using rule 32 (binop -> OPERATOR .)
    DELIMITER       reduce using rule 32 (binop -> OPERATOR .)
    FIRST           reduce using rule 32 (binop -> OPERATOR .)
    REST            reduce using rule 32 (binop -> OPERATOR .)
    CHARACTER       reduce using rule 32 (binop -> OPERATOR .)


state 36

    (3) exp -> IF exp . THEN exp ELSE exp

    THEN            shift and go to state 49


state 37

    (4) exp -> LET def . IN exp

    IN              shift and go to state 50


state 38

    (15) def -> id . EQ exp SEMI_COLON def
    (16) def -> id . EQ exp SEMI_COLON
    (43) id -> id . DIGIT
    (44) id -> id . CHARACTER

    EQ              shift and go to state 51
    DIGIT           shift and go to state 46
    CHARACTER       shift and go to state 47


state 39

    (5) exp -> MAP idlist . TO exp

    TO              shift and go to state 52


state 40

    (21) idlist -> propidlist .

    TO              reduce using rule 21 (idlist -> propidlist .)


state 41

    (23) propidlist -> id . COMMA propidlist
    (24) propidlist -> id .
    (43) id -> id . DIGIT
    (44) id -> id . CHARACTER

    COMMA           shift and go to state 53
    TO              reduce using rule 24 (propidlist -> id .)
    DIGIT           shift and go to state 46
    CHARACTER       shift and go to state 47


state 42

    (6) term -> unop term .

    OPERATOR        reduce using rule 6 (term -> unop term .)
    PLUS            reduce using rule 6 (term -> unop term .)
    MINUS           reduce using rule 6 (term -> unop term .)
    $end            reduce using rule 6 (term -> unop term .)
    THEN            reduce using rule 6 (term -> unop term .)
    CLOSE_PAREN     reduce using rule 6 (term -> unop term .)
    COMMA           reduce using rule 6 (term -> unop term .)
    ELSE            reduce using rule 6 (term -> unop term .)
    SEMI_COLON      reduce using rule 6 (term -> unop term .)


state 43

    (7) term -> factor OPEN_PAREN . explist CLOSE_PAREN
    (17) explist -> . propexplist
    (18) explist -> .
    (19) propexplist -> . exp COMMA propexplist
    (20) propexplist -> . exp
    (1) exp -> . term binop exp
    (2) exp -> . term
    (3) exp -> . IF exp THEN exp ELSE exp
    (4) exp -> . LET def IN exp
    (5) exp -> . MAP idlist TO exp
    (6) term -> . unop term
    (7) term -> . factor OPEN_PAREN explist CLOSE_PAREN
    (8) term -> . factor
    (9) term -> . bool
    (10) term -> . int
    (11) term -> . empty
    (29) unop -> . sign
    (30) unop -> . ~
    (12) factor -> . OPEN_PAREN exp CLOSE_PAREN
    (13) factor -> . prim
    (14) factor -> . id
    (25) bool -> . FALSE
    (26) bool -> . TRUE
    (46) int -> . int DIGIT
    (47) int -> . DIGIT
    (48) empty -> . EMPTY
    (27) sign -> . PLUS
    (28) sign -> . MINUS
    (33) prim -> . NUMBER_Q
    (34) prim -> . CONS_Q
    (35) prim -> . EMPTY_Q
    (36) prim -> . FUNCTION_Q
    (37) prim -> . LIST_Q
    (38) prim -> . ARITY
    (39) prim -> . CONS
    (40) prim -> . DELIMITER
    (41) prim -> . FIRST
    (42) prim -> . REST
    (43) id -> . id DIGIT
    (44) id -> . id CHARACTER
    (45) id -> . CHARACTER

    CLOSE_PAREN     reduce using rule 18 (explist -> .)
    IF              shift and go to state 3
    LET             shift and go to state 4
    MAP             shift and go to state 5
    ~               shift and go to state 13
    OPEN_PAREN      shift and go to state 8
    FALSE           shift and go to state 16
    TRUE            shift and go to state 17
    DIGIT           shift and go to state 18
    EMPTY           shift and go to state 19
    PLUS            shift and go to state 20
    MINUS           shift and go to state 21
    NUMBER_Q        shift and go to state 22
    CONS_Q          shift and go to state 23
    EMPTY_Q         shift and go to state 24
    FUNCTION_Q      shift and go to state 25
    LIST_Q          shift and go to state 26
    ARITY           shift and go to state 27
    CONS            shift and go to state 28
    DELIMITER       shift and go to state 29
    FIRST           shift and go to state 30
    REST            shift and go to state 31
    CHARACTER       shift and go to state 32

    factor                         shift and go to state 7
    explist                        shift and go to state 54
    propexplist                    shift and go to state 55
    exp                            shift and go to state 56
    term                           shift and go to state 2
    unop                           shift and go to state 6
    bool                           shift and go to state 9
    int                            shift and go to state 10
    empty                          shift and go to state 11
    sign                           shift and go to state 12
    prim                           shift and go to state 14
    id                             shift and go to state 15

state 44

    (12) factor -> OPEN_PAREN exp . CLOSE_PAREN

    CLOSE_PAREN     shift and go to state 57


state 45

    (46) int -> int DIGIT .

    DIGIT           reduce using rule 46 (int -> int DIGIT .)
    OPERATOR        reduce using rule 46 (int -> int DIGIT .)
    PLUS            reduce using rule 46 (int -> int DIGIT .)
    MINUS           reduce using rule 46 (int -> int DIGIT .)
    $end            reduce using rule 46 (int -> int DIGIT .)
    THEN            reduce using rule 46 (int -> int DIGIT .)
    CLOSE_PAREN     reduce using rule 46 (int -> int DIGIT .)
    COMMA           reduce using rule 46 (int -> int DIGIT .)
    ELSE            reduce using rule 46 (int -> int DIGIT .)
    SEMI_COLON      reduce using rule 46 (int -> int DIGIT .)


state 46

    (43) id -> id DIGIT .

    DIGIT           reduce using rule 43 (id -> id DIGIT .)
    CHARACTER       reduce using rule 43 (id -> id DIGIT .)
    OPEN_PAREN      reduce using rule 43 (id -> id DIGIT .)
    OPERATOR        reduce using rule 43 (id -> id DIGIT .)
    PLUS            reduce using rule 43 (id -> id DIGIT .)
    MINUS           reduce using rule 43 (id -> id DIGIT .)
    $end            reduce using rule 43 (id -> id DIGIT .)
    THEN            reduce using rule 43 (id -> id DIGIT .)
    EQ              reduce using rule 43 (id -> id DIGIT .)
    COMMA           reduce using rule 43 (id -> id DIGIT .)
    TO              reduce using rule 43 (id -> id DIGIT .)
    CLOSE_PAREN     reduce using rule 43 (id -> id DIGIT .)
    ELSE            reduce using rule 43 (id -> id DIGIT .)
    SEMI_COLON      reduce using rule 43 (id -> id DIGIT .)


state 47

    (44) id -> id CHARACTER .

    DIGIT           reduce using rule 44 (id -> id CHARACTER .)
    CHARACTER       reduce using rule 44 (id -> id CHARACTER .)
    OPEN_PAREN      reduce using rule 44 (id -> id CHARACTER .)
    OPERATOR        reduce using rule 44 (id -> id CHARACTER .)
    PLUS            reduce using rule 44 (id -> id CHARACTER .)
    MINUS           reduce using rule 44 (id -> id CHARACTER .)
    $end            reduce using rule 44 (id -> id CHARACTER .)
    THEN            reduce using rule 44 (id -> id CHARACTER .)
    EQ              reduce using rule 44 (id -> id CHARACTER .)
    COMMA           reduce using rule 44 (id -> id CHARACTER .)
    TO              reduce using rule 44 (id -> id CHARACTER .)
    CLOSE_PAREN     reduce using rule 44 (id -> id CHARACTER .)
    ELSE            reduce using rule 44 (id -> id CHARACTER .)
    SEMI_COLON      reduce using rule 44 (id -> id CHARACTER .)


state 48

    (1) exp -> term binop exp .

    $end            reduce using rule 1 (exp -> term binop exp .)
    THEN            reduce using rule 1 (exp -> term binop exp .)
    CLOSE_PAREN     reduce using rule 1 (exp -> term binop exp .)
    COMMA           reduce using rule 1 (exp -> term binop exp .)
    ELSE            reduce using rule 1 (exp -> term binop exp .)
    SEMI_COLON      reduce using rule 1 (exp -> term binop exp .)


state 49

    (3) exp -> IF exp THEN . exp ELSE exp
    (1) exp -> . term binop exp
    (2) exp -> . term
    (3) exp -> . IF exp THEN exp ELSE exp
    (4) exp -> . LET def IN exp
    (5) exp -> . MAP idlist TO exp
    (6) term -> . unop term
    (7) term -> . factor OPEN_PAREN explist CLOSE_PAREN
    (8) term -> . factor
    (9) term -> . bool
    (10) term -> . int
    (11) term -> . empty
    (29) unop -> . sign
    (30) unop -> . ~
    (12) factor -> . OPEN_PAREN exp CLOSE_PAREN
    (13) factor -> . prim
    (14) factor -> . id
    (25) bool -> . FALSE
    (26) bool -> . TRUE
    (46) int -> . int DIGIT
    (47) int -> . DIGIT
    (48) empty -> . EMPTY
    (27) sign -> . PLUS
    (28) sign -> . MINUS
    (33) prim -> . NUMBER_Q
    (34) prim -> . CONS_Q
    (35) prim -> . EMPTY_Q
    (36) prim -> . FUNCTION_Q
    (37) prim -> . LIST_Q
    (38) prim -> . ARITY
    (39) prim -> . CONS
    (40) prim -> . DELIMITER
    (41) prim -> . FIRST
    (42) prim -> . REST
    (43) id -> . id DIGIT
    (44) id -> . id CHARACTER
    (45) id -> . CHARACTER

    IF              shift and go to state 3
    LET             shift and go to state 4
    MAP             shift and go to state 5
    ~               shift and go to state 13
    OPEN_PAREN      shift and go to state 8
    FALSE           shift and go to state 16
    TRUE            shift and go to state 17
    DIGIT           shift and go to state 18
    EMPTY           shift and go to state 19
    PLUS            shift and go to state 20
    MINUS           shift and go to state 21
    NUMBER_Q        shift and go to state 22
    CONS_Q          shift and go to state 23
    EMPTY_Q         shift and go to state 24
    FUNCTION_Q      shift and go to state 25
    LIST_Q          shift and go to state 26
    ARITY           shift and go to state 27
    CONS            shift and go to state 28
    DELIMITER       shift and go to state 29
    FIRST           shift and go to state 30
    REST            shift and go to state 31
    CHARACTER       shift and go to state 32

    exp                            shift and go to state 58
    term                           shift and go to state 2
    unop                           shift and go to state 6
    factor                         shift and go to state 7
    bool                           shift and go to state 9
    int                            shift and go to state 10
    empty                          shift and go to state 11
    sign                           shift and go to state 12
    prim                           shift and go to state 14
    id                             shift and go to state 15

state 50

    (4) exp -> LET def IN . exp
    (1) exp -> . term binop exp
    (2) exp -> . term
    (3) exp -> . IF exp THEN exp ELSE exp
    (4) exp -> . LET def IN exp
    (5) exp -> . MAP idlist TO exp
    (6) term -> . unop term
    (7) term -> . factor OPEN_PAREN explist CLOSE_PAREN
    (8) term -> . factor
    (9) term -> . bool
    (10) term -> . int
    (11) term -> . empty
    (29) unop -> . sign
    (30) unop -> . ~
    (12) factor -> . OPEN_PAREN exp CLOSE_PAREN
    (13) factor -> . prim
    (14) factor -> . id
    (25) bool -> . FALSE
    (26) bool -> . TRUE
    (46) int -> . int DIGIT
    (47) int -> . DIGIT
    (48) empty -> . EMPTY
    (27) sign -> . PLUS
    (28) sign -> . MINUS
    (33) prim -> . NUMBER_Q
    (34) prim -> . CONS_Q
    (35) prim -> . EMPTY_Q
    (36) prim -> . FUNCTION_Q
    (37) prim -> . LIST_Q
    (38) prim -> . ARITY
    (39) prim -> . CONS
    (40) prim -> . DELIMITER
    (41) prim -> . FIRST
    (42) prim -> . REST
    (43) id -> . id DIGIT
    (44) id -> . id CHARACTER
    (45) id -> . CHARACTER

    IF              shift and go to state 3
    LET             shift and go to state 4
    MAP             shift and go to state 5
    ~               shift and go to state 13
    OPEN_PAREN      shift and go to state 8
    FALSE           shift and go to state 16
    TRUE            shift and go to state 17
    DIGIT           shift and go to state 18
    EMPTY           shift and go to state 19
    PLUS            shift and go to state 20
    MINUS           shift and go to state 21
    NUMBER_Q        shift and go to state 22
    CONS_Q          shift and go to state 23
    EMPTY_Q         shift and go to state 24
    FUNCTION_Q      shift and go to state 25
    LIST_Q          shift and go to state 26
    ARITY           shift and go to state 27
    CONS            shift and go to state 28
    DELIMITER       shift and go to state 29
    FIRST           shift and go to state 30
    REST            shift and go to state 31
    CHARACTER       shift and go to state 32

    exp                            shift and go to state 59
    term                           shift and go to state 2
    unop                           shift and go to state 6
    factor                         shift and go to state 7
    bool                           shift and go to state 9
    int                            shift and go to state 10
    empty                          shift and go to state 11
    sign                           shift and go to state 12
    prim                           shift and go to state 14
    id                             shift and go to state 15

state 51

    (15) def -> id EQ . exp SEMI_COLON def
    (16) def -> id EQ . exp SEMI_COLON
    (1) exp -> . term binop exp
    (2) exp -> . term
    (3) exp -> . IF exp THEN exp ELSE exp
    (4) exp -> . LET def IN exp
    (5) exp -> . MAP idlist TO exp
    (6) term -> . unop term
    (7) term -> . factor OPEN_PAREN explist CLOSE_PAREN
    (8) term -> . factor
    (9) term -> . bool
    (10) term -> . int
    (11) term -> . empty
    (29) unop -> . sign
    (30) unop -> . ~
    (12) factor -> . OPEN_PAREN exp CLOSE_PAREN
    (13) factor -> . prim
    (14) factor -> . id
    (25) bool -> . FALSE
    (26) bool -> . TRUE
    (46) int -> . int DIGIT
    (47) int -> . DIGIT
    (48) empty -> . EMPTY
    (27) sign -> . PLUS
    (28) sign -> . MINUS
    (33) prim -> . NUMBER_Q
    (34) prim -> . CONS_Q
    (35) prim -> . EMPTY_Q
    (36) prim -> . FUNCTION_Q
    (37) prim -> . LIST_Q
    (38) prim -> . ARITY
    (39) prim -> . CONS
    (40) prim -> . DELIMITER
    (41) prim -> . FIRST
    (42) prim -> . REST
    (43) id -> . id DIGIT
    (44) id -> . id CHARACTER
    (45) id -> . CHARACTER

    IF              shift and go to state 3
    LET             shift and go to state 4
    MAP             shift and go to state 5
    ~               shift and go to state 13
    OPEN_PAREN      shift and go to state 8
    FALSE           shift and go to state 16
    TRUE            shift and go to state 17
    DIGIT           shift and go to state 18
    EMPTY           shift and go to state 19
    PLUS            shift and go to state 20
    MINUS           shift and go to state 21
    NUMBER_Q        shift and go to state 22
    CONS_Q          shift and go to state 23
    EMPTY_Q         shift and go to state 24
    FUNCTION_Q      shift and go to state 25
    LIST_Q          shift and go to state 26
    ARITY           shift and go to state 27
    CONS            shift and go to state 28
    DELIMITER       shift and go to state 29
    FIRST           shift and go to state 30
    REST            shift and go to state 31
    CHARACTER       shift and go to state 32

    id                             shift and go to state 15
    exp                            shift and go to state 60
    term                           shift and go to state 2
    unop                           shift and go to state 6
    factor                         shift and go to state 7
    bool                           shift and go to state 9
    int                            shift and go to state 10
    empty                          shift and go to state 11
    sign                           shift and go to state 12
    prim                           shift and go to state 14

state 52

    (5) exp -> MAP idlist TO . exp
    (1) exp -> . term binop exp
    (2) exp -> . term
    (3) exp -> . IF exp THEN exp ELSE exp
    (4) exp -> . LET def IN exp
    (5) exp -> . MAP idlist TO exp
    (6) term -> . unop term
    (7) term -> . factor OPEN_PAREN explist CLOSE_PAREN
    (8) term -> . factor
    (9) term -> . bool
    (10) term -> . int
    (11) term -> . empty
    (29) unop -> . sign
    (30) unop -> . ~
    (12) factor -> . OPEN_PAREN exp CLOSE_PAREN
    (13) factor -> . prim
    (14) factor -> . id
    (25) bool -> . FALSE
    (26) bool -> . TRUE
    (46) int -> . int DIGIT
    (47) int -> . DIGIT
    (48) empty -> . EMPTY
    (27) sign -> . PLUS
    (28) sign -> . MINUS
    (33) prim -> . NUMBER_Q
    (34) prim -> . CONS_Q
    (35) prim -> . EMPTY_Q
    (36) prim -> . FUNCTION_Q
    (37) prim -> . LIST_Q
    (38) prim -> . ARITY
    (39) prim -> . CONS
    (40) prim -> . DELIMITER
    (41) prim -> . FIRST
    (42) prim -> . REST
    (43) id -> . id DIGIT
    (44) id -> . id CHARACTER
    (45) id -> . CHARACTER

    IF              shift and go to state 3
    LET             shift and go to state 4
    MAP             shift and go to state 5
    ~               shift and go to state 13
    OPEN_PAREN      shift and go to state 8
    FALSE           shift and go to state 16
    TRUE            shift and go to state 17
    DIGIT           shift and go to state 18
    EMPTY           shift and go to state 19
    PLUS            shift and go to state 20
    MINUS           shift and go to state 21
    NUMBER_Q        shift and go to state 22
    CONS_Q          shift and go to state 23
    EMPTY_Q         shift and go to state 24
    FUNCTION_Q      shift and go to state 25
    LIST_Q          shift and go to state 26
    ARITY           shift and go to state 27
    CONS            shift and go to state 28
    DELIMITER       shift and go to state 29
    FIRST           shift and go to state 30
    REST            shift and go to state 31
    CHARACTER       shift and go to state 32

    exp                            shift and go to state 61
    term                           shift and go to state 2
    unop                           shift and go to state 6
    factor                         shift and go to state 7
    bool                           shift and go to state 9
    int                            shift and go to state 10
    empty                          shift and go to state 11
    sign                           shift and go to state 12
    prim                           shift and go to state 14
    id                             shift and go to state 15

state 53

    (23) propidlist -> id COMMA . propidlist
    (23) propidlist -> . id COMMA propidlist
    (24) propidlist -> . id
    (43) id -> . id DIGIT
    (44) id -> . id CHARACTER
    (45) id -> . CHARACTER

    CHARACTER       shift and go to state 32

    id                             shift and go to state 41
    propidlist                     shift and go to state 62

state 54

    (7) term -> factor OPEN_PAREN explist . CLOSE_PAREN

    CLOSE_PAREN     shift and go to state 63


state 55

    (17) explist -> propexplist .

    CLOSE_PAREN     reduce using rule 17 (explist -> propexplist .)


state 56

    (19) propexplist -> exp . COMMA propexplist
    (20) propexplist -> exp .

    COMMA           shift and go to state 64
    CLOSE_PAREN     reduce using rule 20 (propexplist -> exp .)


state 57

    (12) factor -> OPEN_PAREN exp CLOSE_PAREN .

    OPEN_PAREN      reduce using rule 12 (factor -> OPEN_PAREN exp CLOSE_PAREN .)
    OPERATOR        reduce using rule 12 (factor -> OPEN_PAREN exp CLOSE_PAREN .)
    PLUS            reduce using rule 12 (factor -> OPEN_PAREN exp CLOSE_PAREN .)
    MINUS           reduce using rule 12 (factor -> OPEN_PAREN exp CLOSE_PAREN .)
    $end            reduce using rule 12 (factor -> OPEN_PAREN exp CLOSE_PAREN .)
    THEN            reduce using rule 12 (factor -> OPEN_PAREN exp CLOSE_PAREN .)
    CLOSE_PAREN     reduce using rule 12 (factor -> OPEN_PAREN exp CLOSE_PAREN .)
    COMMA           reduce using rule 12 (factor -> OPEN_PAREN exp CLOSE_PAREN .)
    ELSE            reduce using rule 12 (factor -> OPEN_PAREN exp CLOSE_PAREN .)
    SEMI_COLON      reduce using rule 12 (factor -> OPEN_PAREN exp CLOSE_PAREN .)


state 58

    (3) exp -> IF exp THEN exp . ELSE exp

    ELSE            shift and go to state 65


state 59

    (4) exp -> LET def IN exp .

    $end            reduce using rule 4 (exp -> LET def IN exp .)
    THEN            reduce using rule 4 (exp -> LET def IN exp .)
    CLOSE_PAREN     reduce using rule 4 (exp -> LET def IN exp .)
    COMMA           reduce using rule 4 (exp -> LET def IN exp .)
    ELSE            reduce using rule 4 (exp -> LET def IN exp .)
    SEMI_COLON      reduce using rule 4 (exp -> LET def IN exp .)


state 60

    (15) def -> id EQ exp . SEMI_COLON def
    (16) def -> id EQ exp . SEMI_COLON

    SEMI_COLON      shift and go to state 66


state 61

    (5) exp -> MAP idlist TO exp .

    $end            reduce using rule 5 (exp -> MAP idlist TO exp .)
    THEN            reduce using rule 5 (exp -> MAP idlist TO exp .)
    CLOSE_PAREN     reduce using rule 5 (exp -> MAP idlist TO exp .)
    COMMA           reduce using rule 5 (exp -> MAP idlist TO exp .)
    ELSE            reduce using rule 5 (exp -> MAP idlist TO exp .)
    SEMI_COLON      reduce using rule 5 (exp -> MAP idlist TO exp .)


state 62

    (23) propidlist -> id COMMA propidlist .

    TO              reduce using rule 23 (propidlist -> id COMMA propidlist .)


state 63

    (7) term -> factor OPEN_PAREN explist CLOSE_PAREN .

    OPERATOR        reduce using rule 7 (term -> factor OPEN_PAREN explist CLOSE_PAREN .)
    PLUS            reduce using rule 7 (term -> factor OPEN_PAREN explist CLOSE_PAREN .)
    MINUS           reduce using rule 7 (term -> factor OPEN_PAREN explist CLOSE_PAREN .)
    $end            reduce using rule 7 (term -> factor OPEN_PAREN explist CLOSE_PAREN .)
    THEN            reduce using rule 7 (term -> factor OPEN_PAREN explist CLOSE_PAREN .)
    CLOSE_PAREN     reduce using rule 7 (term -> factor OPEN_PAREN explist CLOSE_PAREN .)
    COMMA           reduce using rule 7 (term -> factor OPEN_PAREN explist CLOSE_PAREN .)
    ELSE            reduce using rule 7 (term -> factor OPEN_PAREN explist CLOSE_PAREN .)
    SEMI_COLON      reduce using rule 7 (term -> factor OPEN_PAREN explist CLOSE_PAREN .)


state 64

    (19) propexplist -> exp COMMA . propexplist
    (19) propexplist -> . exp COMMA propexplist
    (20) propexplist -> . exp
    (1) exp -> . term binop exp
    (2) exp -> . term
    (3) exp -> . IF exp THEN exp ELSE exp
    (4) exp -> . LET def IN exp
    (5) exp -> . MAP idlist TO exp
    (6) term -> . unop term
    (7) term -> . factor OPEN_PAREN explist CLOSE_PAREN
    (8) term -> . factor
    (9) term -> . bool
    (10) term -> . int
    (11) term -> . empty
    (29) unop -> . sign
    (30) unop -> . ~
    (12) factor -> . OPEN_PAREN exp CLOSE_PAREN
    (13) factor -> . prim
    (14) factor -> . id
    (25) bool -> . FALSE
    (26) bool -> . TRUE
    (46) int -> . int DIGIT
    (47) int -> . DIGIT
    (48) empty -> . EMPTY
    (27) sign -> . PLUS
    (28) sign -> . MINUS
    (33) prim -> . NUMBER_Q
    (34) prim -> . CONS_Q
    (35) prim -> . EMPTY_Q
    (36) prim -> . FUNCTION_Q
    (37) prim -> . LIST_Q
    (38) prim -> . ARITY
    (39) prim -> . CONS
    (40) prim -> . DELIMITER
    (41) prim -> . FIRST
    (42) prim -> . REST
    (43) id -> . id DIGIT
    (44) id -> . id CHARACTER
    (45) id -> . CHARACTER

    IF              shift and go to state 3
    LET             shift and go to state 4
    MAP             shift and go to state 5
    ~               shift and go to state 13
    OPEN_PAREN      shift and go to state 8
    FALSE           shift and go to state 16
    TRUE            shift and go to state 17
    DIGIT           shift and go to state 18
    EMPTY           shift and go to state 19
    PLUS            shift and go to state 20
    MINUS           shift and go to state 21
    NUMBER_Q        shift and go to state 22
    CONS_Q          shift and go to state 23
    EMPTY_Q         shift and go to state 24
    FUNCTION_Q      shift and go to state 25
    LIST_Q          shift and go to state 26
    ARITY           shift and go to state 27
    CONS            shift and go to state 28
    DELIMITER       shift and go to state 29
    FIRST           shift and go to state 30
    REST            shift and go to state 31
    CHARACTER       shift and go to state 32

    exp                            shift and go to state 56
    propexplist                    shift and go to state 67
    term                           shift and go to state 2
    unop                           shift and go to state 6
    factor                         shift and go to state 7
    bool                           shift and go to state 9
    int                            shift and go to state 10
    empty                          shift and go to state 11
    sign                           shift and go to state 12
    prim                           shift and go to state 14
    id                             shift and go to state 15

state 65

    (3) exp -> IF exp THEN exp ELSE . exp
    (1) exp -> . term binop exp
    (2) exp -> . term
    (3) exp -> . IF exp THEN exp ELSE exp
    (4) exp -> . LET def IN exp
    (5) exp -> . MAP idlist TO exp
    (6) term -> . unop term
    (7) term -> . factor OPEN_PAREN explist CLOSE_PAREN
    (8) term -> . factor
    (9) term -> . bool
    (10) term -> . int
    (11) term -> . empty
    (29) unop -> . sign
    (30) unop -> . ~
    (12) factor -> . OPEN_PAREN exp CLOSE_PAREN
    (13) factor -> . prim
    (14) factor -> . id
    (25) bool -> . FALSE
    (26) bool -> . TRUE
    (46) int -> . int DIGIT
    (47) int -> . DIGIT
    (48) empty -> . EMPTY
    (27) sign -> . PLUS
    (28) sign -> . MINUS
    (33) prim -> . NUMBER_Q
    (34) prim -> . CONS_Q
    (35) prim -> . EMPTY_Q
    (36) prim -> . FUNCTION_Q
    (37) prim -> . LIST_Q
    (38) prim -> . ARITY
    (39) prim -> . CONS
    (40) prim -> . DELIMITER
    (41) prim -> . FIRST
    (42) prim -> . REST
    (43) id -> . id DIGIT
    (44) id -> . id CHARACTER
    (45) id -> . CHARACTER

    IF              shift and go to state 3
    LET             shift and go to state 4
    MAP             shift and go to state 5
    ~               shift and go to state 13
    OPEN_PAREN      shift and go to state 8
    FALSE           shift and go to state 16
    TRUE            shift and go to state 17
    DIGIT           shift and go to state 18
    EMPTY           shift and go to state 19
    PLUS            shift and go to state 20
    MINUS           shift and go to state 21
    NUMBER_Q        shift and go to state 22
    CONS_Q          shift and go to state 23
    EMPTY_Q         shift and go to state 24
    FUNCTION_Q      shift and go to state 25
    LIST_Q          shift and go to state 26
    ARITY           shift and go to state 27
    CONS            shift and go to state 28
    DELIMITER       shift and go to state 29
    FIRST           shift and go to state 30
    REST            shift and go to state 31
    CHARACTER       shift and go to state 32

    exp                            shift and go to state 68
    term                           shift and go to state 2
    unop                           shift and go to state 6
    factor                         shift and go to state 7
    bool                           shift and go to state 9
    int                            shift and go to state 10
    empty                          shift and go to state 11
    sign                           shift and go to state 12
    prim                           shift and go to state 14
    id                             shift and go to state 15

state 66

    (15) def -> id EQ exp SEMI_COLON . def
    (16) def -> id EQ exp SEMI_COLON .
    (15) def -> . id EQ exp SEMI_COLON def
    (16) def -> . id EQ exp SEMI_COLON
    (43) id -> . id DIGIT
    (44) id -> . id CHARACTER
    (45) id -> . CHARACTER

    IN              reduce using rule 16 (def -> id EQ exp SEMI_COLON .)
    CHARACTER       shift and go to state 32

    id                             shift and go to state 38
    def                            shift and go to state 69

state 67

    (19) propexplist -> exp COMMA propexplist .

    CLOSE_PAREN     reduce using rule 19 (propexplist -> exp COMMA propexplist .)


state 68

    (3) exp -> IF exp THEN exp ELSE exp .

    $end            reduce using rule 3 (exp -> IF exp THEN exp ELSE exp .)
    THEN            reduce using rule 3 (exp -> IF exp THEN exp ELSE exp .)
    CLOSE_PAREN     reduce using rule 3 (exp -> IF exp THEN exp ELSE exp .)
    COMMA           reduce using rule 3 (exp -> IF exp THEN exp ELSE exp .)
    ELSE            reduce using rule 3 (exp -> IF exp THEN exp ELSE exp .)
    SEMI_COLON      reduce using rule 3 (exp -> IF exp THEN exp ELSE exp .)


state 69

    (15) def -> id EQ exp SEMI_COLON def .

    IN              reduce using rule 15 (def -> id EQ exp SEMI_COLON def .)

